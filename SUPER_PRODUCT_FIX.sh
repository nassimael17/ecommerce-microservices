#!/bin/bash

echo "üöÄ Starting SUPER PRODUCT REPAIR SCRIPT..."

# 1. Discover Postgres Container
POSTGRES_CONTAINER=$(docker ps --format '{{.Names}}' | grep "postgres" | head -n 1)
if [ -z "$POSTGRES_CONTAINER" ]; then
    echo "‚ùå Error: Postgres container not found."
    exit 1
fi

# 2. Advanced Database Fix (ID Identity & Columns)
echo "üóÑÔ∏è  1. Patching Database Schema..."
SQL_FIX=$(cat <<EOF
-- Fix Product Table ID generation
DO \$\$
BEGIN
    -- Ensure available column exists
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='product' AND column_name='available') THEN
        ALTER TABLE product ADD COLUMN available BOOLEAN DEFAULT TRUE;
        UPDATE product SET available = TRUE;
    END IF;
    
    -- Ensure image_url column exists
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='product' AND column_name='image_url') THEN
        ALTER TABLE product ADD COLUMN image_url VARCHAR(255);
    END IF;

    -- CRITICAL: Ensure 'id' is an identity column (autoincrement)
    -- If it was imported from a dump it might be just an 'int'
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='product' AND column_name='id' AND is_identity='YES') THEN
        BEGIN
            -- This works on Postgres 10+
            ALTER TABLE product ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;
        EXCEPTION WHEN OTHERS THEN
            -- Fallback for older/custom setups
            CREATE SEQUENCE IF NOT EXISTS product_id_seq;
            ALTER TABLE product ALTER COLUMN id SET DEFAULT nextval('product_id_seq');
            PERFORM setval('product_id_seq', coalesce(max(id), 1)) FROM product;
        END;
    END IF;
END \$\$;

-- Fix sequence sync for all tables
SELECT setval(pg_get_serial_sequence('product', 'id'), coalesce(max(id), 1)) FROM product;
SELECT setval(pg_get_serial_sequence('clients', 'id'), coalesce(max(id), 1)) FROM clients;
SELECT setval(pg_get_serial_sequence('orders', 'id'), coalesce(max(id), 1)) FROM orders;
EOF
)
docker exec -i "$POSTGRES_CONTAINER" psql -U postgres -d ecommerce -c "$SQL_FIX"

# 3. Patching Java Logic for Better Logging & Debugging
echo "üìù 2. Patching Java Files for Production Stability..."

# Path to Product files
PROD_BASE="product-service/product-service/src/main/java/com/ecommerce/product/service"

# A. Update ProductController to LOG errors properly
cat <<EOF > "$PROD_BASE/controller/ProductController.java"
package com.ecommerce.product.service.controller;

import com.ecommerce.product.service.model.Product;
import com.ecommerce.product.service.service.ProductService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "*")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping
    public List<Product> getAllProducts() {
        return productService.getAllProducts();
    }

    @GetMapping("/{id}")
    public ResponseEntity<Product> getProductById(@PathVariable Long id) {
        return productService.getProductById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<?> createProduct(@RequestBody Product product) {
        try {
            System.out.println("üì• Receiving Product: " + product);
            product.setAvailable(true); // Force available for new products
            Product saved = productService.createProduct(product);
            return ResponseEntity.status(HttpStatus.CREATED).body(saved);
        } catch (Exception e) {
            System.err.println("‚ùå Error saving product: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error: " + e.getMessage());
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateProduct(@PathVariable Long id, @RequestBody Product product) {
        try {
            return productService.updateProduct(id, product)
                    .map(ResponseEntity::ok)
                    .orElse(ResponseEntity.notFound().build());
        } catch (Exception e) {
            System.err.println("‚ùå Error updating product: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error: " + e.getMessage());
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{id}/reduce-stock")
    public ResponseEntity<Void> reduceStock(@PathVariable Long id, @RequestParam int quantity) {
        productService.reduceStock(id, quantity);
        return ResponseEntity.ok().build();
    }
}
EOF

# 4. Final Case Sensitivity Check (Gateway & Feign)
echo "üî° 3. Ensuring Everything is Uppercase (Eureka Standard)..."
find . -name "*.java" -o -name "*.yml" | xargs sed -i 's/product-service/PRODUCT-SERVICE/g' 2>/dev/null
find . -name "*.java" -o -name "*.yml" | xargs sed -i 's/order-service/ORDER-SERVICE/g' 2>/dev/null
find . -name "*.java" -o -name "*.yml" | xargs sed -i 's/client-service/CLIENT-SERVICE/g' 2>/dev/null
find . -name "*.java" -o -name "*.yml" | xargs sed -i 's/payment-service/PAYMENT-SERVICE/g' 2>/dev/null

# 5. Rebuild & Restart
echo "üõ†Ô∏è  4. Rebuilding Product Service (with new logging)..."
docker-compose up -d --build product-service api-gateway order-service

echo "‚ú® DONE! Tell her to wait 1 minute, then check the dashboard."
echo "If she still gets an error, ask her to run: docker logs ecommerce-microservices-product-service-1"
